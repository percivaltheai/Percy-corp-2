/**
 * siwa.ts
 *
 * SIWA (Sign In With Agent) utility functions.
 * Provides message building, signing (agent-side), and verification (server-side).
 *
 * Dependencies:
 *   npm install viem
 */
import { type PublicClient } from 'viem';
import { AgentProfile, ServiceType, TrustModel } from './registry.js';
import type { Signer, SignerType } from './signer/index.js';
import type { SIWANonceStore } from './nonce-store.js';
import { type CaptchaChallenge, type CaptchaPolicy, type CaptchaOptions } from './captcha.js';
export declare enum SIWAErrorCode {
    INVALID_SIGNATURE = "INVALID_SIGNATURE",
    DOMAIN_MISMATCH = "DOMAIN_MISMATCH",
    INVALID_NONCE = "INVALID_NONCE",
    MESSAGE_EXPIRED = "MESSAGE_EXPIRED",
    MESSAGE_NOT_YET_VALID = "MESSAGE_NOT_YET_VALID",
    INVALID_REGISTRY_FORMAT = "INVALID_REGISTRY_FORMAT",
    NOT_REGISTERED = "NOT_REGISTERED",
    NOT_OWNER = "NOT_OWNER",
    AGENT_NOT_ACTIVE = "AGENT_NOT_ACTIVE",
    MISSING_SERVICE = "MISSING_SERVICE",
    MISSING_TRUST_MODEL = "MISSING_TRUST_MODEL",
    LOW_REPUTATION = "LOW_REPUTATION",
    CUSTOM_CHECK_FAILED = "CUSTOM_CHECK_FAILED",
    VERIFICATION_FAILED = "VERIFICATION_FAILED",
    CAPTCHA_REQUIRED = "CAPTCHA_REQUIRED",
    CAPTCHA_FAILED = "CAPTCHA_FAILED"
}
export interface SIWAMessageFields {
    domain: string;
    address: string;
    statement?: string;
    uri: string;
    version?: string;
    agentId: number;
    agentRegistry: string;
    chainId: number;
    nonce: string;
    issuedAt: string;
    expirationTime?: string;
    notBefore?: string;
    requestId?: string;
}
export interface SIWAVerificationResult {
    valid: boolean;
    address: string;
    agentId: number;
    agentRegistry: string;
    chainId: number;
    verified: 'offline' | 'onchain';
    signerType?: SignerType;
    code?: SIWAErrorCode;
    error?: string;
    agent?: AgentProfile;
}
export interface SIWAVerifyCriteria {
    minScore?: number;
    minFeedbackCount?: number;
    reputationRegistryAddress?: string;
    requiredServices?: (ServiceType | (string & {}))[];
    mustBeActive?: boolean;
    requiredTrust?: (TrustModel | (string & {}))[];
    allowedSignerTypes?: SignerType[];
    custom?: (agent: AgentProfile) => boolean | Promise<boolean>;
}
export interface SIWAResponse {
    status: 'authenticated' | 'not_registered' | 'rejected';
    address?: string;
    agentId?: number;
    agentRegistry?: string;
    chainId?: number;
    verified?: 'offline' | 'onchain';
    signerType?: SignerType;
    code?: SIWAErrorCode;
    error?: string;
    action?: SIWAAction;
    skill?: {
        name: string;
        install: string;
        url: string;
    };
}
export interface SIWAAction {
    type: 'register';
    message: string;
    skill: {
        name: string;
        install: string;
        url: string;
    };
    steps: string[];
    registryAddress?: string;
    chainId?: number;
}
/**
 * Convert a SIWAVerificationResult into a standard SIWAResponse
 * that platforms can forward directly to agents.
 */
export declare function buildSIWAResponse(result: SIWAVerificationResult): SIWAResponse;
/**
 * Build a SIWA plaintext message string from structured fields.
 */
export declare function buildSIWAMessage(fields: SIWAMessageFields): string;
/**
 * Parse a SIWA message string back into structured fields.
 */
export declare function parseSIWAMessage(message: string): SIWAMessageFields;
/**
 * Generate a cryptographically secure nonce (≥ 8 alphanumeric characters).
 */
export declare function generateNonce(length?: number): string;
export interface SIWANonceParams {
    address: string;
    agentId: number;
    agentRegistry: string;
    challengeResponse?: string;
}
export interface SIWANonceOptions {
    expirationTTL?: number;
    secret?: string;
    nonceStore?: SIWANonceStore;
    captchaPolicy?: CaptchaPolicy;
    captchaOptions?: CaptchaOptions;
}
export type SIWANonceResult = {
    status: 'nonce_issued';
    nonce: string;
    nonceToken?: string;
    issuedAt: string;
    expirationTime: string;
} | {
    status: 'captcha_required';
    challenge: CaptchaChallenge;
    challengeToken: string;
} | SIWAResponse;
/**
 * Validate agent registration and create a SIWA nonce.
 *
 * Platforms call this in their nonce endpoint. The function checks onchain
 * that the agent NFT exists and is owned by the requesting address **before**
 * issuing a nonce. This lets the agent fail fast with actionable registration
 * instructions instead of going through the full sign → verify cycle.
 *
 * The nonce and timestamps are returned to the platform, which is responsible
 * for storing them and validating them later during verification.
 *
 * @param params   Agent identity (address, agentId, agentRegistry)
 * @param client   viem PublicClient for onchain registration check
 * @param options  Optional config (expirationTTL)
 * @returns        `{ status: 'nonce_issued', nonce, ... }` on success, or a `SIWAResponse` on failure
 */
export declare function createSIWANonce(params: SIWANonceParams, client: PublicClient, options?: SIWANonceOptions): Promise<SIWANonceResult>;
/**
 * Fields accepted by signSIWAMessage.
 * `address` is optional — when omitted, the address is fetched directly
 * from the signer (the trusted source of truth for the agent wallet).
 */
export type SIWASignFields = Omit<SIWAMessageFields, 'address'> & {
    address?: string;
};
/**
 * Sign a SIWA message using the provided signer.
 *
 * The signer abstracts the wallet implementation, allowing you to use:
 *   - createKeyringProxySigner(config)   — Keyring proxy server
 *   - createLocalAccountSigner(account)  — viem LocalAccount (private key)
 *   - createWalletClientSigner(client)   — viem WalletClient (Privy, MetaMask, etc.)
 *
 * The agent address is always resolved from the signer — the single source
 * of truth — so the caller doesn't need to supply (or risk hallucinating) it.
 * If `fields.address` is provided it must match the signer's address.
 *
 * @param fields — SIWA message fields (domain, agentId, etc.). `address` is optional.
 * @param signer — A Signer implementation (see createKeyringProxySigner, createLocalAccountSigner, createWalletClientSigner)
 * @returns { message, signature, address } — the plaintext message, EIP-191 signature, and resolved address
 *
 * @example
 * ```typescript
 * import { signSIWAMessage, createLocalAccountSigner } from '@buildersgarden/siwa';
 * import { privateKeyToAccount } from 'viem/accounts';
 *
 * const account = privateKeyToAccount('0x...');
 * const signer = createLocalAccountSigner(account);
 *
 * const { message, signature, address } = await signSIWAMessage({
 *   domain: 'example.com',
 *   uri: 'https://example.com/login',
 *   agentId: 123,
 *   agentRegistry: 'eip155:84532:0x...',
 *   chainId: 84532,
 *   nonce: 'abc123',
 *   issuedAt: new Date().toISOString(),
 * }, signer);
 * ```
 */
export declare function signSIWAMessage(fields: SIWASignFields, signer: Signer): Promise<{
    message: string;
    signature: string;
    address: string;
}>;
/**
 * Nonce validation: either a callback (stateful) or a stateless token + secret.
 *
 * Stateful (callback):
 *   Platform stores nonces server-side and provides a validation function.
 *
 * Stateless (nonceToken + secret):
 *   The SDK verifies the HMAC token issued by createSIWANonce({ secret }).
 *   No server-side storage needed — ideal for serverless platforms.
 */
export type NonceValidator = ((nonce: string) => boolean | Promise<boolean>) | {
    nonceToken: string;
    secret: string;
} | {
    nonceStore: SIWANonceStore;
};
/**
 * Verify a SIWA message + signature.
 *
 * Checks:
 * 1. Message format validity
 * 2. Signature → address recovery
 * 3. Address matches message
 * 4. Domain matches expected domain
 * 5. Nonce matches (caller must validate against their nonce store or stateless token)
 * 6. Time window (expirationTime / notBefore)
 * 7. Onchain: ownerOf(agentId) === recovered address
 *
 * @param message    Full SIWA message string
 * @param signature  EIP-191 signature hex string
 * @param expectedDomain  The server's domain (for domain binding)
 * @param nonceValid  Callback or { nonceToken, secret } for stateless validation
 * @param client   viem PublicClient for onchain verification
 * @param criteria   Optional criteria to validate agent profile/reputation after ownership check
 */
export declare function verifySIWA(message: string, signature: string, expectedDomain: string, nonceValid: NonceValidator, client: PublicClient, criteria?: SIWAVerifyCriteria): Promise<SIWAVerificationResult>;
