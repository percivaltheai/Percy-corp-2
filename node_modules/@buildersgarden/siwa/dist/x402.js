/**
 * x402.ts
 *
 * Framework-agnostic x402 payment protocol integration.
 *
 * Provides types, header constants, base64 encode/decode helpers,
 * a facilitator HTTP client, and a high-level processX402Payment function.
 *
 * No framework imports. No `@x402/*` dependency — the facilitator API
 * is just 2 HTTP POSTs (verify + settle).
 */
// ---------------------------------------------------------------------------
// Header constants
// ---------------------------------------------------------------------------
export const X402_HEADERS = {
    PAYMENT_REQUIRED: 'Payment-Required',
    PAYMENT_SIGNATURE: 'Payment-Signature',
    PAYMENT_RESPONSE: 'Payment-Response',
};
// ---------------------------------------------------------------------------
// Base64 JSON encode / decode
// ---------------------------------------------------------------------------
/**
 * Encode data as a base64 JSON string for use in HTTP headers.
 */
export function encodeX402Header(data) {
    const json = JSON.stringify(data);
    if (typeof Buffer !== 'undefined') {
        return Buffer.from(json).toString('base64');
    }
    return btoa(json);
}
/**
 * Decode a base64 JSON header value.
 */
export function decodeX402Header(header) {
    let json;
    if (typeof Buffer !== 'undefined') {
        json = Buffer.from(header, 'base64').toString('utf-8');
    }
    else {
        json = atob(header);
    }
    return JSON.parse(json);
}
// ---------------------------------------------------------------------------
// Facilitator client
// ---------------------------------------------------------------------------
/**
 * Create a facilitator client that communicates via HTTP.
 *
 * The x402 facilitator exposes two endpoints:
 *   - POST /verify — validates a payment signature
 *   - POST /settle — settles the payment on-chain
 */
export function createFacilitatorClient(options) {
    const baseUrl = options.url.replace(/\/+$/, '');
    return {
        async verify(payload, requirements) {
            const res = await fetch(`${baseUrl}/verify`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ payload, requirements }),
            });
            if (!res.ok) {
                const text = await res.text().catch(() => res.statusText);
                throw new Error(`Facilitator verify failed (${res.status}): ${text}`);
            }
            return res.json();
        },
        async settle(payload, requirements) {
            const res = await fetch(`${baseUrl}/settle`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ payload, requirements }),
            });
            if (!res.ok) {
                const text = await res.text().catch(() => res.statusText);
                throw new Error(`Facilitator settle failed (${res.status}): ${text}`);
            }
            return res.json();
        },
    };
}
// ---------------------------------------------------------------------------
// Session store — in-memory
// ---------------------------------------------------------------------------
/**
 * In-memory X402 session store with TTL-based expiry.
 *
 * Suitable for single-process servers. For multi-instance deployments,
 * implement X402SessionStore with a shared store (Redis, database, etc.).
 */
export function createMemoryX402SessionStore() {
    const sessions = new Map();
    function cleanup() {
        const now = Date.now();
        for (const [k, v] of sessions) {
            if (v.expiry < now)
                sessions.delete(k);
        }
    }
    return {
        async get(address, resource) {
            cleanup();
            const key = `${address}:${resource}`;
            const entry = sessions.get(key);
            if (!entry)
                return null;
            if (entry.expiry < Date.now()) {
                sessions.delete(key);
                return null;
            }
            return entry.session;
        },
        async set(address, resource, session, ttlMs) {
            cleanup();
            const key = `${address}:${resource}`;
            sessions.set(key, { session, expiry: Date.now() + ttlMs });
        },
    };
}
// ---------------------------------------------------------------------------
// Payment processing
// ---------------------------------------------------------------------------
/**
 * Verify and settle an x402 payment in one call.
 *
 * 1. Calls facilitator.verify() to validate the payment signature
 * 2. If valid, calls facilitator.settle() to execute the on-chain transfer
 * 3. Returns the payment details with transaction hash
 */
export async function processX402Payment(payload, accepts, facilitator) {
    // 1. Verify the payment signature
    const verifyResult = await facilitator.verify(payload, accepts);
    if (!verifyResult.valid) {
        return {
            valid: false,
            error: `Payment verification failed: ${verifyResult.reason ?? 'unknown'}`,
        };
    }
    // 2. Settle the payment on-chain
    const settleResult = await facilitator.settle(payload, accepts);
    if (!settleResult.success) {
        return {
            valid: false,
            error: `Payment settlement failed: ${settleResult.reason ?? 'unknown'}`,
        };
    }
    return {
        valid: true,
        payment: {
            scheme: payload.payment.scheme,
            network: payload.payment.network,
            amount: payload.payment.amount,
            asset: payload.payment.asset,
            payTo: payload.payment.payTo,
            txHash: settleResult.txHash,
        },
    };
}
