/**
 * erc8128.ts
 *
 * Full ERC-8128 HTTP Message Signatures integration for SIWA.
 *
 * The SDK fully abstracts `@slicekit/erc8128`. Platform developers call:
 *   - signAuthenticatedRequest()   — agent-side: attach receipt + sign request
 *   - verifyAuthenticatedRequest() — server-side: verify signature + receipt + optional onchain
 *
 * These are the two main entry points. Everything else is internal.
 */
import type { Address, PublicClient } from 'viem';
import { type EthHttpSigner, type NonceStore } from '@slicekit/erc8128';
import type { Signer, SignerType } from './signer/index.js';
import { type CaptchaChallenge, type CaptchaPolicy, type CaptchaOptions, type CaptchaSolver } from './captcha.js';
export interface VerifyOptions {
    receiptSecret: string;
    rpcUrl?: string;
    verifyOnchain?: boolean;
    publicClient?: PublicClient;
    nonceStore?: NonceStore;
    allowedSignerTypes?: SignerType[];
    captchaPolicy?: CaptchaPolicy;
    captchaOptions?: CaptchaOptions;
}
/** Verified agent identity returned from a successful auth check. */
export interface SiwaAgent {
    address: string;
    agentId: number;
    agentRegistry: string;
    chainId: number;
    signerType?: SignerType;
}
export type AuthResult = {
    valid: true;
    agent: SiwaAgent;
} | {
    valid: false;
    error: string;
} | {
    valid: false;
    error: string;
    captchaRequired: true;
    challenge: CaptchaChallenge;
    challengeToken: string;
};
/**
 * Resolve the receipt secret from an explicit value or environment variables.
 *
 * Checks (in order): `explicit` → `RECEIPT_SECRET` env → `SIWA_SECRET` env → throws.
 */
export declare function resolveReceiptSecret(explicit?: string): string;
/** Header name for the verification receipt */
export declare const RECEIPT_HEADER = "X-SIWA-Receipt";
/**
 * Create an ERC-8128 HTTP signer from a SIWA Signer.
 *
 * The `signMessage` callback converts the RFC 9421 signature base
 * (Uint8Array) to a hex string and delegates to the signer.
 *
 * @param signer - A SIWA Signer (createKeyringProxySigner, createLocalAccountSigner, etc.)
 * @param chainId - Chain ID for the ERC-8128 keyid
 * @param options - Optional overrides (e.g. signerAddress for TBA identity)
 * @returns An EthHttpSigner for use with @slicekit/erc8128
 */
export declare function createErc8128Signer(signer: Signer, chainId: number, options?: {
    signerAddress?: Address;
}): Promise<EthHttpSigner>;
/**
 * Attach a verification receipt to a request.
 *
 * Sets the `X-SIWA-Receipt` header.
 */
export declare function attachReceipt(request: Request, receipt: string): Request;
/**
 * Sign an authenticated request: attach receipt + ERC-8128 signature.
 *
 * This is the main function platform developers use on the agent side.
 * One call does everything:
 *   1. Attaches the receipt header
 *   2. Creates an ERC-8128 signer from the SIWA signer
 *   3. Signs the request with HTTP Message Signatures (RFC 9421)
 *
 * @param request  The outgoing Request object
 * @param receipt  Verification receipt from SIWA sign-in
 * @param signer   A SIWA Signer (createKeyringProxySigner, createLocalAccountSigner, etc.)
 * @param chainId  Chain ID for the ERC-8128 keyid
 * @param options  Optional overrides (e.g. signerAddress for TBA identity)
 * @returns        A new Request with Signature, Signature-Input, Content-Digest, and X-SIWA-Receipt headers
 *
 * @example
 * ```typescript
 * import { signAuthenticatedRequest, createLocalAccountSigner } from '@buildersgarden/siwa';
 * import { privateKeyToAccount } from 'viem/accounts';
 *
 * const account = privateKeyToAccount('0x...');
 * const signer = createLocalAccountSigner(account);
 *
 * const signedRequest = await signAuthenticatedRequest(
 *   new Request('https://api.example.com/data'),
 *   receipt,
 *   signer,
 *   84532
 * );
 * ```
 */
export declare function signAuthenticatedRequest(request: Request, receipt: string, signer: Signer, chainId: number, options?: {
    signerAddress?: Address;
}): Promise<Request>;
/**
 * Detect a captcha challenge in a server response and build a re-signed retry request.
 *
 * When a server returns 401 with `{ captchaRequired: true, challenge, challengeToken }`,
 * this function:
 *   1. Extracts the challenge from the response body
 *   2. Calls the solver to generate solution text
 *   3. Packs the solution into the `X-SIWA-Challenge-Response` header
 *   4. Re-signs the request with ERC-8128 (binding the challenge response into the signature)
 *   5. Returns the new signed request ready for retry
 *
 * **Important:** The `request` parameter must be a fresh, unconsumed Request
 * (not the one already sent via `fetch`). Keep the original URL, method, headers,
 * and body around so you can reconstruct it for the retry.
 *
 * @param response  The server's 401 response (body is read via `.clone()`, so the original stays readable)
 * @param request   A fresh, unconsumed Request matching the original call
 * @param receipt   Verification receipt from SIWA sign-in
 * @param signer    A SIWA Signer
 * @param chainId   Chain ID for the ERC-8128 keyid
 * @param solver    Callback that generates solution text from a challenge
 * @param options   Optional overrides (e.g. signerAddress for TBA identity)
 * @returns `{ retry: true, request }` with the signed retry request, or `{ retry: false }` if no captcha
 *
 * @example
 * ```typescript
 * import { signAuthenticatedRequest, retryWithCaptcha } from '@buildersgarden/siwa/erc8128';
 *
 * const url = 'https://api.example.com/action';
 * const body = JSON.stringify({ key: 'value' });
 *
 * // First attempt
 * const signed = await signAuthenticatedRequest(
 *   new Request(url, { method: 'POST', body }),
 *   receipt, signer, 84532,
 * );
 * const response = await fetch(signed);
 *
 * // Handle captcha if required
 * const result = await retryWithCaptcha(
 *   response,
 *   new Request(url, { method: 'POST', body }), // fresh request
 *   receipt, signer, 84532,
 *   async (challenge) => generateText(challenge), // your LLM solver
 * );
 *
 * if (result.retry) {
 *   const retryResponse = await fetch(result.request);
 * }
 * ```
 */
export declare function retryWithCaptcha(response: Response, request: Request, receipt: string, signer: Signer, chainId: number, solver: CaptchaSolver, options?: {
    signerAddress?: Address;
}): Promise<{
    retry: true;
    request: Request;
} | {
    retry: false;
}>;
/**
 * Verify an authenticated request: ERC-8128 signature + receipt + optional onchain check.
 *
 * This is the main function platform developers use on the server side.
 * One call does everything:
 *   1. Extracts and verifies the HMAC receipt
 *   2. Verifies the ERC-8128 HTTP signature (recovers signer address)
 *   3. Checks that the signer address matches the receipt address
 *   4. Optionally does an onchain ownerOf check
 *
 * @param request  The incoming Request object (with Signature + X-SIWA-Receipt headers)
 * @param options  Verification options (receipt secret, optional onchain settings)
 * @returns        `{ valid: true, agent }` or `{ valid: false, error }`
 */
export declare function verifyAuthenticatedRequest(request: Request, options: VerifyOptions): Promise<AuthResult>;
/**
 * Convert an Express request to a Fetch API Request.
 *
 * Needed because ERC-8128 operates on the Fetch `Request` object,
 * but Express uses its own request type.
 *
 * @param req  Express request object (must have `rawBody` for Content-Digest verification)
 */
export declare function expressToFetchRequest(req: {
    method: string;
    protocol: string;
    get: (name: string) => string | undefined;
    originalUrl: string;
    headers: Record<string, string | string[] | undefined>;
    rawBody?: string;
}): Request;
/**
 * Normalize a Next.js/serverless Request for ERC-8128 verification.
 *
 * Behind reverse proxies (Vercel, Railway, Cloudflare), the request URL
 * may reflect internal routing instead of the public origin. This helper
 * reads X-Forwarded-Host / X-Forwarded-Proto headers and reconstructs
 * the URL to match what the agent signed.
 */
export declare function nextjsToFetchRequest(req: Request): Request;
