/**
 * captcha.ts
 *
 * Reverse CAPTCHA — inspired by MoltCaptcha (https://github.com/MoltCaptcha/MoltCaptcha).
 *
 * Challenges exploit how LLMs generate text in a single autoregressive pass
 * (satisfying multiple constraints simultaneously), while humans must iterate.
 *
 * Two integration points:
 *   1. Sign-in flow — server can require captcha before issuing a nonce
 *   2. Per-request — middleware randomly challenges agents during authenticated API calls
 *
 * No external dependencies — only `node:crypto`.
 */
export type CaptchaDifficulty = 'easy' | 'medium' | 'hard' | 'extreme';
export type CaptchaFormat = 'haiku' | 'quatrain' | 'free_verse' | 'micro_story';
export interface CaptchaChallenge {
    topic: string;
    format: CaptchaFormat;
    lineCount: number;
    asciiTarget: number;
    wordCount?: number;
    charPosition?: [number, string];
    totalChars?: number;
    timeLimitSeconds: number;
    difficulty: CaptchaDifficulty;
    createdAt: number;
}
export interface CaptchaSolution {
    text: string;
    solvedAt: number;
}
export interface CaptchaVerificationResult {
    asciiSum: {
        pass: boolean;
        actual: number;
        target: number;
    };
    lineCount?: {
        pass: boolean;
        actual: number;
        target: number;
    };
    wordCount?: {
        pass: boolean;
        actual: number;
        target: number;
    };
    charPosition?: {
        pass: boolean;
    };
    totalChars?: {
        pass: boolean;
        actual: number;
        target?: number;
    };
    timing: {
        pass: boolean;
        elapsedSeconds: number;
    };
    overallPass: boolean;
    verdict: 'VERIFIED_AI_AGENT' | 'CHALLENGE_FAILED';
}
export type CaptchaPolicy = (context: {
    address: string;
    agentId: number;
    agentRegistry: string;
    request?: Request;
}) => CaptchaDifficulty | null | Promise<CaptchaDifficulty | null>;
export interface CaptchaVerifyOptions {
    /** Use server wall-clock time instead of trusting the agent's solvedAt. Default: true */
    useServerTiming?: boolean;
    /** Extra seconds added to time limit for network latency. Default: 2 */
    timingToleranceSeconds?: number;
    /** Whether verification results include actual vs target values. Default: true */
    revealConstraints?: boolean;
    /** Tolerance for ASCII sum comparison (±N). Default: 0 (exact match) */
    asciiTolerance?: number;
    /** Callback to consume a challenge token (one-time use). Return false to reject replays. */
    consumeChallenge?: (challengeToken: string) => boolean | Promise<boolean>;
}
export interface CaptchaOptions {
    secret: string;
    topics?: string[];
    formats?: CaptchaFormat[];
    /** Override difficulty settings per tier */
    difficulties?: Partial<Record<CaptchaDifficulty, Partial<DifficultyConfig>>>;
    /** Verification options (passed through to verifyCaptchaSolution) */
    verify?: CaptchaVerifyOptions;
}
export declare const CHALLENGE_HEADER = "X-SIWA-Challenge";
export declare const CHALLENGE_RESPONSE_HEADER = "X-SIWA-Challenge-Response";
export interface DifficultyConfig {
    timeLimitSeconds: number;
    lineCount: [number, number];
    useWordCount: boolean;
    useCharPosition: boolean;
    useTotalChars: boolean;
}
/**
 * Generate a captcha challenge and HMAC-signed token.
 *
 * @param difficulty  Challenge difficulty tier
 * @param options     Secret for HMAC signing + optional topic/format pools
 * @returns           `{ challenge, challengeToken }` — the challenge data and its signed token
 */
export declare function createCaptchaChallenge(difficulty: CaptchaDifficulty, options: CaptchaOptions): {
    challenge: CaptchaChallenge;
    challengeToken: string;
};
/**
 * Verify a captcha solution against a signed challenge token.
 *
 * @param challengeToken  HMAC-signed token from createCaptchaChallenge
 * @param solution        The agent's solution (text + timestamp)
 * @param secret          HMAC secret used to sign the token
 * @param options         Verification options (timing, tolerance, replay protection, redaction)
 * @returns               Verification result, or `null` if the token is invalid/replayed
 */
export declare function verifyCaptchaSolution(challengeToken: string, solution: CaptchaSolution, secret: string, options?: CaptchaVerifyOptions): Promise<CaptchaVerificationResult | null>;
/**
 * Callback that receives a captcha challenge and returns the solution text.
 *
 * Typically implemented by prompting an LLM to generate text that satisfies
 * all constraints (line count, ASCII sum, word count, etc.) in a single pass.
 */
export type CaptchaSolver = (challenge: CaptchaChallenge) => string | Promise<string>;
/**
 * Detect and solve a captcha challenge from a nonce response.
 *
 * When a server's nonce endpoint returns `{ status: 'captcha_required' }`,
 * this helper calls the solver, packs the response, and returns a
 * `challengeResponse` string for the agent to include in the retry request.
 *
 * @param nonceResponse  The parsed JSON body from the nonce endpoint
 * @param solver         Callback that generates solution text from a challenge
 * @returns `{ solved: true, challengeResponse }` if captcha was solved,
 *          `{ solved: false }` if no captcha was required
 *
 * @example
 * ```typescript
 * import { solveCaptchaChallenge } from '@buildersgarden/siwa/captcha';
 *
 * const res = await fetch('/siwa/nonce', { method: 'POST', body: JSON.stringify(params) });
 * const nonceResult = await res.json();
 *
 * const captcha = await solveCaptchaChallenge(nonceResult, async (challenge) => {
 *   // LLM generates text satisfying all constraints
 *   return await generateText(challenge); // your LLM solver
 * });
 *
 * if (captcha.solved) {
 *   // Retry with challenge response
 *   const retry = await fetch('/siwa/nonce', {
 *     method: 'POST',
 *     body: JSON.stringify({ ...params, challengeResponse: captcha.challengeResponse }),
 *   });
 * }
 * ```
 */
export declare function solveCaptchaChallenge(nonceResponse: {
    status: string;
    challenge?: CaptchaChallenge;
    challengeToken?: string;
}, solver: CaptchaSolver): Promise<{
    solved: true;
    challengeResponse: string;
} | {
    solved: false;
}>;
/**
 * Package a captcha solution for submission (agent-side).
 *
 * @param challengeToken  The challenge token received from the server
 * @param text            The agent's solution text
 * @returns               A packed string to send in the challenge response header/field
 */
export declare function packCaptchaResponse(challengeToken: string, text: string): string;
/**
 * Unpack a captcha response (server-side).
 *
 * @param packed  The base64url-encoded response from the agent
 * @returns       The challenge token and solution, or `null` if malformed
 */
export declare function unpackCaptchaResponse(packed: string): {
    challengeToken: string;
    solution: CaptchaSolution;
} | null;
