// Generated by dts-bundle-generator v9.5.1

export type Hex = `0x${string}`;
export type Address = `0x${string}`;
export type VerifyMessageArgs = {
	address: Address;
	message: {
		raw: Hex;
	};
	signature: Hex;
};
export type VerifyMessageFn = (args: VerifyMessageArgs) => boolean | Promise<boolean>;
export type SetHeadersFn = (name: string, value: string) => void;
export type BindingMode = "request-bound" | "class-bound";
export type ReplayMode = "non-replayable" | "replayable";
export type ContentDigestMode = "auto" | "recompute" | "require" | "off";
export type SignOptions = {
	label?: string;
	binding?: BindingMode;
	replay?: ReplayMode;
	created?: number;
	expires?: number;
	ttlSeconds?: number;
	nonce?: string | (() => Promise<string>);
	contentDigest?: ContentDigestMode;
	components?: string[];
};
export interface EthHttpSigner {
	/** Address to put in keyid and to authenticate as (EOA or SCA). */
	address: Address;
	chainId: number;
	/**
	 * Sign RFC9421 signature base bytes as an Ethereum message (EIP-191).
	 * Return signature bytes as hex (may be 65 bytes for EOA, arbitrary length for SCA-style signatures).
	 */
	signMessage: (message: Uint8Array) => Promise<Hex>;
}
export interface NonceStore {
	/**
	 * Atomic consume: returns true if newly stored (i.e. not seen), false if already exists.
	 * ttlSeconds: how long the nonce should remain reserved.
	 */
	consume(key: string, ttlSeconds: number): Promise<boolean>;
}
export type VerifyPolicy = {
	/** Preferred label to verify (default "eth"). If not found, verifier can fall back to first label unless strictLabel=true. */
	label?: string;
	strictLabel?: boolean;
	/** Extra components required in addition to default request-bound set. */
	additionalRequestBoundComponents?: string[];
	/** Class-bound components policies (one list or a list of lists). @authority is always required. */
	classBoundPolicies?: string[] | string[][];
	/** Allow replayable (nonce-less) signatures (default false). */
	replayable?: boolean;
	/**
	 * Optional replayable invalidation policy.
	 * When set and a signature is replayable, requests with created < notBefore are rejected.
	 * Return null/undefined to indicate "no cutoff".
	 */
	replayableNotBefore?: (keyid: string) => number | null | undefined | Promise<number | null | undefined>;
	/**
	 * Optional per-signature invalidation policy for replayable signatures.
	 * Return true to mark the signature as invalidated.
	 */
	replayableInvalidated?: (args: {
		keyid: string;
		created: number;
		expires: number;
		label: string;
		signature: Hex;
		signatureBase: Uint8Array;
		signatureParamsValue: string;
	}) => boolean | Promise<boolean>;
	/** Maximum number of signatures to verify (default 3). */
	maxSignatureVerifications?: number;
	/** Time policy */
	now?: () => number;
	clockSkewSec?: number;
	maxValiditySec?: number;
	maxNonceWindowSec?: number;
	/** Replay protection */
	nonceKey?: (keyid: string, nonce: string) => string;
};
export type SignatureParams = {
	created: number;
	expires: number;
	keyid: string;
	nonce?: string;
	tag?: string;
};
export type VerifyResult = {
	ok: true;
	address: Address;
	chainId: number;
	label: string;
	components: string[];
	params: SignatureParams;
	replayable: boolean;
	binding: BindingMode;
} | {
	ok: false;
	reason: VerifyFailReason;
	detail?: string;
};
export type VerifyFailReason = "missing_headers" | "label_not_found" | "bad_signature_input" | "bad_signature" | "bad_keyid" | "bad_time" | "not_yet_valid" | "expired" | "validity_too_long" | "nonce_required" | "replayable_not_allowed" | "replayable_invalidation_required" | "replayable_not_before" | "replayable_invalidated" | "class_bound_not_allowed" | "not_request_bound" | "nonce_window_too_long" | "replay" | "digest_mismatch" | "digest_required" | "alg_not_allowed" | "bad_signature_bytes" | "bad_signature_check";
export declare class Erc8128Error extends Error {
	code: "CRYPTO_UNAVAILABLE" | "INVALID_OPTIONS" | "UNSUPPORTED_REQUEST" | "BODY_READ_FAILED" | "DIGEST_REQUIRED" | "BAD_DERIVED_VALUE" | "BAD_HEADER_VALUE" | "PARSE_ERROR";
	constructor(code: "CRYPTO_UNAVAILABLE" | "INVALID_OPTIONS" | "UNSUPPORTED_REQUEST" | "BODY_READ_FAILED" | "DIGEST_REQUIRED" | "BAD_DERIVED_VALUE" | "BAD_HEADER_VALUE" | "PARSE_ERROR", message: string);
}
export type ClientOptions = SignOptions & {
	fetch?: typeof fetch;
};
export type Client = {
	signRequest: {
		(input: RequestInfo, opts?: SignOptions): Promise<Request>;
		(input: RequestInfo, init: RequestInit | undefined, opts?: SignOptions): Promise<Request>;
	};
	signedFetch: {
		(input: RequestInfo, opts?: ClientOptions): Promise<Response>;
		(input: RequestInfo, init: RequestInit | undefined, opts?: ClientOptions): Promise<Response>;
	};
	fetch: {
		(input: RequestInfo, opts?: ClientOptions): Promise<Response>;
		(input: RequestInfo, init: RequestInit | undefined, opts?: ClientOptions): Promise<Response>;
	};
};
export declare function createSignerClient(signer: EthHttpSigner, defaults?: ClientOptions): Client;
export declare function formatKeyId(chainId: number, address: Address): string;
export declare function parseKeyId(keyid: string): {
	chainId: number;
	address: Address;
} | null;
/**
 *   Minimal ERC-8128 signing
 * - Fetch-first: works in browsers, workers, Node 18+.
 * - Minimal RFC 9421 engine: message to sign is an ERFC9421 compliant signature base.
 * - Minimal Structured Fields serialization: enough to serialize Signature-Input + Signature for one label.
 *
 *   IMPORTANT:
 * - This is "signing side" only. Verification is not included here.
 * - For Request-Bound with body: we compute Content-Digest using SHA-256 and include it when required.
 * - SHA-256 requires WebCrypto (crypto.subtle) or Node 'node:crypto'. The library will throw CRYPTO_UNAVAILABLE if neither is available.
 */
/**
 * Sign a fetch Request (or RequestInfo+RequestInit) and return a NEW Request with:
 * - Signature-Input
 * - Signature
 * - Content-Digest (if required)
 */
export declare function signRequest(input: RequestInfo, signer: EthHttpSigner, opts?: SignOptions): Promise<Request>;
export declare function signRequest(input: RequestInfo, init: RequestInit | undefined, signer: EthHttpSigner, opts?: SignOptions): Promise<Request>;
export declare function signedFetch(input: RequestInfo, signer: EthHttpSigner, opts?: SignOptions & {
	fetch?: typeof fetch;
}): Promise<Response>;
export declare function signedFetch(input: RequestInfo, init: RequestInit | undefined, signer: EthHttpSigner, opts?: SignOptions & {
	fetch?: typeof fetch;
}): Promise<Response>;
export type VerifierClientOptions = VerifyPolicy;
export type VerifierClient = {
	verifyRequest: (request: Request, policy?: VerifyPolicy, setHeaders?: SetHeadersFn) => Promise<VerifyResult>;
};
export declare function createVerifierClient(verifyMessage: VerifyMessageFn, nonceStore: NonceStore, defaults?: VerifierClientOptions): VerifierClient;
export declare function verifyRequest(request: Request, verifyMessage: VerifyMessageFn, nonceStore: NonceStore, policy?: VerifyPolicy, setHeaders?: SetHeadersFn): Promise<VerifyResult>;

export {};
